package com.farm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.net.URI;
import java.util.*;

import static java.util.stream.Collectors.groupingBy;

/**
 * @RestController - Make this class a rest controller that receive and return JSON
 * JSON - Javascript Object Notation
 * @RequestMapping - Define the resource path of the controller
 */
@RestController
@RequestMapping("api/animals")
public class AnimalController {

    /** Get the bean called AnimalRepository, which is auto-generated by Spring */
    @Autowired
    private AnimalRepository animalRepository;

    /** Data-Annotation that map the controller to receive HTTP POST method in path: api/animals
     *
     * @param animal sent by request body
     * @return status 201 when created with success, and the resource uri with id of the animal created
     *
     * @RequestBody Annotation indicating a method parameter should be bound to the body of the HTTP request.
     * ResponseEntity represents the whole HTTP response: status code, headers, and body.
     * Because of it, we can use it to fully configure the HTTP response.
     * In this case return object of type Void
     */
    @PostMapping
    public ResponseEntity<Void> insert(@RequestBody Animal animal) {

        // Use animalRepository object to save the animal sent by request body
        Animal createdAnimal = animalRepository.save(animal);

        // return ResponseEntity<Void> object using created method to return URI location header
        return ResponseEntity.created(URI.create("api/animals/" + createdAnimal.getId())).build();
    }

    /**
     * Data-Annotation that map the controller to receive HTTP GET method in path: api/animals/averageWeight
     * ResponseEntity represents the whole HTTP response: status code, headers, and body.
     * Because of it, we can use it to fully configure the HTTP response.
     * In this case return object of type List<AverageWeight>
     */
    @GetMapping("/averageWeight")
    public ResponseEntity<List<AverageWeight>> averageWeight() {

        // Create average weight list
        List<AverageWeight> averageWeightList = new ArrayList<>();

        // Uses AnimalRepository object to get all animals
        List<Animal> animals = animalRepository.findAll();

        // Group animals by AnimalType using java 8 stream
        Map<AnimalType, List<Animal>> animalsByType = animals.stream().collect(groupingBy(Animal::getType));

        // performs calculation to take the average of each list of animals and add an object
        // to averageWeightList object
        animalsByType.forEach((animalType, animalList) -> {
            animalList.forEach(x -> System.out.println(x.getWeight()));
            OptionalDouble optionalDouble =
                    animalList.stream()
                            .mapToDouble(x -> x.getWeight() != null ? x.getWeight().doubleValue() : 0.00)
                            .average();

            double average = 0.00;

            if (optionalDouble.isPresent()){ average = optionalDouble.getAsDouble(); }

            averageWeightList.add(new AverageWeight(animalType, BigDecimal.valueOf(average)));
        });

        // return ResponseEntity<List<AverageWeight>> using ok to return on response body
        return ResponseEntity.ok(averageWeightList);
    }

    /**
     * Data-Annotation that map the controller to receive HTTP GET method in path: api/animals/howManyCanBeSold
     * ResponseEntity represents the whole HTTP response: status code, headers, and body.
     *  Because of it, we can use it to fully configure the HTTP response.
     *  In this case return object of type List<HowManyCanBeSold>
     */
    @GetMapping("/howManyCanBeSold")
    public ResponseEntity<List<HowManyCanBeSold>> howManyCanBeSold() {

        // Create HowManyCanBeSold object ArrayList
        List<HowManyCanBeSold> howManyCanBeSoldList = new ArrayList<>();

        // Uses AnimalRepository object to get all animals
        List<Animal> animals = animalRepository.findAll();

        // Group animals by AnimalType using java 8 stream
        Map<AnimalType, List<Animal>> animalsByType = animals.stream().collect(groupingBy(Animal::getType));

        // Filter all animal can be sold and return the number of objects filtered
        animalsByType.forEach((animalType, animalList) -> {
            long count = animalList.stream()
                    .filter(animal -> animal.canBeSold())
                    .count();

            // Add HowManyCanBeSold object to howManyCanBeSoldList object
            howManyCanBeSoldList.add(new HowManyCanBeSold(animalType, count));
        });

        // return ResponseEntity<List<HowManyCanBeSold>> using ok to return on response body
        return ResponseEntity.ok(howManyCanBeSoldList);
    }

    /**
     * Data-Annotation that map the controller to receive HTTP GET method in path: api/animals/currentValueOfFullFarmStock
     * ResponseEntity represents the whole HTTP response: status code, headers, and body.
     *      * Because of it, we can use it to fully configure the HTTP response.
     */
    @GetMapping("/currentValueOfFullFarmStock")
    public ResponseEntity<CurrentValue> currentFullFarmStock() {

        // Uses AnimalRepository object to get all animals
        List<Animal> animals = animalRepository.findAll();

        // Filter all animal that can be sold
        // map to double value and return sum
        double sum = animals.stream()
                .filter(animal -> animal.canBeSold())
                .mapToDouble(animal -> animal.getType().getMarketValue().doubleValue())
                .sum();

        // return ResponseEntity<CurrentValue> using ok to return on response body
        return ResponseEntity.ok(new CurrentValue(BigDecimal.valueOf(sum)));
    }

    /**
     * Data-Annotation that map the controller to receive HTTP GET method in path: api/animals/currentValue
     * @param cowValue custom value to COW animal type, defaultValue property define the default value if not passed from
     *                 request params
     * @param chickenValue custom value to CHICKEN animal type, defaultValue property define the default value if not passed from
     *                     request params
     * @param pigValue custom value to PIG animal type, defaultValue property define the default value if not passed from
     *                 request params
     * @RequestParam is annotation that map the query param passed from url to java object
     *
     * return @ResponseEntity
     * ResponseEntity represents the whole HTTP response: status code, headers, and body.
     * Because of it, we can use it to fully configure the HTTP response.
     * In this case return object of type CurrentValue
     */
    @GetMapping("/currentValue")
    public ResponseEntity<CurrentValue> currentValue(
            @RequestParam(value = "cow" , defaultValue = "0") BigDecimal cowValue,
            @RequestParam(value = "pig", defaultValue = "0") BigDecimal pigValue,
            @RequestParam(value = "chicken", defaultValue = "0") BigDecimal chickenValue) {

        // Use the animalRepository object that return all animals from database using
        // Spring Data JPA
        List<Animal> animals = animalRepository.findAll();

        // Filter all animals that can be sold
        // and map to double value using internal method resolveAnimalPrice by animal type
        // and sum the market value defined by enum AnimalType or custom value from request query param
        final double sum = animals.stream()
                .filter(animal -> animal.canBeSold())
                .mapToDouble(animal -> {

                    final AnimalType animalType = animal.getType();

                    if (AnimalType.CHICKEN.equals(animal.getType())) return resolveAnimalPrice(animalType, chickenValue);
                    if (AnimalType.PIG.equals(animal.getType())) return resolveAnimalPrice(animalType, pigValue);
                    if (AnimalType.COW.equals(animal.getType())) return resolveAnimalPrice(animalType, cowValue);

                    return 0;
                }).sum();

        // return ResponseEntity<CurrentValue> using ok to return on response body
        return ResponseEntity.ok(new CurrentValue(BigDecimal.valueOf(sum)));
    }

    // Internal method to resolve animal price
    // if has custom value return custom value
    // if not have custom value return AnimalType market value
    private double resolveAnimalPrice(AnimalType animalType, BigDecimal customValue) {
        return (customValue.doubleValue() == 0 ? animalType.getMarketValue() : customValue).doubleValue();
    }
}
